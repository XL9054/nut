[TOC]

#1、软件的生命周期（8个阶段）

**问题定义**、**可行性研究**（*技术、资金、法律、市场*）、**需求分析**（*深入了解客户需求*）、**概要设计**（类似与盖楼的施工图纸）、**详细设计**（针对具体模块的设计）、**编码和单元测试**（开发人员写代码，测试人员进行测试）、**综合测试**（所有研发已经完成，进行的综合测试）、**软件维护**。

**回归测试**：是对旧功能的测试

**冒烟测试**：对主功能的测试

**单元测试**：属于白盒测试的一种，是测试的最小单位。

#2、软件开发过程模型

##2.1瀑布模型

![1646962943721](C:\Users\asus\AppData\Local\Temp\1646962943721.png)

1.需求分析：分析客户的需求（需求分析最重要）

2.设计：对要研发的软件进行设计

3.编码：开发人员进行编码

4.实现：开发人员完成软件

5.软件测试：测试人员对软件进行测试

6.完成：测试通过

7.维护：运维人员进行相关的维护

**优点：**

​           1）开发各阶段比较清晰；

​           2）当前一个过程完成后，只需要关注下一个阶段。

**缺点：**

​             1）不适应需求变化；

​            2）风险往往到后期才会显露，失去及早纠正的机会；

​            3）前面发现的问题传递扩散到后面，可能导致项目失败。

##2.2增量模型（模块模型）

![1646964168609](C:\Users\asus\AppData\Local\Temp\1646964168609.png)

![1646964333391](C:\Users\asus\AppData\Local\Temp\1646964333391.png)

优点：1）软件系统模块化，可以分批次提交软件产品

​             2）降低软件开发风险

​             3）可以调整模块开发的优先级

缺点：要求系统可以模块化，给增量开发带来麻烦（如果某个系统不容易分割）

##2.3敏捷模型（使用比较多）

开发团队（敏捷开发） 测试团队（敏捷测试）

以软件产品为中心，其他的都不重要

![1646964985608](C:\Users\asus\AppData\Local\Temp\1646964985608.png)

敏捷测试与传统测试的区别

敏捷测试：经常变动 

传统测试：按测试计划进行测试

![1646965576090](C:\Users\asus\AppData\Local\Temp\1646965576090.png)

#3、软件测试的概念，目的，意义，前景

##3.1软件测试：

预期结果（心里设想的结果）、实际结果（实际产生的结果）

当预期结果=实际结果，程序没有问题。

##3.2软件测试的分类

1）根据测试阶段进行分类：单元测试、冒烟测试、集成测试、系统测试、验收测试

2）根据测试的技术进行分类：黑盒测试、白盒测试

3）根据软件的质量特性分类：功能测试、性能测试（压力测试、负载测试、兼容性测试、可移植性测试、健壮性测试）

4）根据自动化程度进行分类：自动化测试、手工测试

##3.3目的

在于发现错误bug,在用户使用之前发现

功能性需求、性能性需求、易用性、可靠性。

![1646966053101](C:\Users\asus\AppData\Local\Temp\1646966053101.png)

##3.4软件测试的意义

1）提高软件质量；

2）保障软件的安全；

3）降低软件开发成本；

4）降低因软件缺陷带来的商业风险；

5）为用户接受软件提供有力的依据；

6）树立用户对软件的信心。

##3.5软件测试（**预防为主**）的前景

![1646968487048](C:\Users\asus\AppData\Local\Temp\1646968487048.png)

#4、软件测试过程模型

##4.1V模型

![1646969168575](C:\Users\asus\AppData\Local\Temp\1646969168575.png)

单元测试：测试里面最小的单位，可以是一个类，一个方法

集成测试：对单独的模块进行测试--测试各个模块之间的接口

系统测试：对整个系统的功能、性能、健壮性的测试

验收测试：甲方人员做的测试。

**V模型的优点：**

1.包含底层测试、高层测试

2.清楚标识出软件开发阶段

3.工作明确，有利于了解开发阶段。

**缺点：**

1.不适应需求的变化

2.错误发生比较不容易调整

##4.2 W模型

![1647003654252](C:\Users\asus\AppData\Local\Temp\1647003654252.png)**特点：**

1.测试伴随着整个软件开发周期

2.测试的对象不仅是程序、需求、设计等同样要测试

3.测试与开发是同步进行的

4.需求、设计、编码等活动视为串行。

**优点：**

有利于尽早地全面发现问题，有利于降低开发成本。

**缺点：**

1.无法支持迭代的开发模型---不支持敏捷开发

2.当前软件开发复杂多变，w模型不能解除测试管理面临的困惑。

![1647004470621](C:\Users\asus\AppData\Local\Temp\1647004470621.png)

#5、软件测试过程

1.需求分析、评审（从客户那边收集到需求，与开发沟通需求的可行性）

2.编写测试计划

3.编写测试用例、用例评审

4.执行测试（提交bug及回归测试）

5.测试总结报告

![1647008222028](C:\Users\asus\AppData\Local\Temp\1647008222028.png)

##5.1需求分析

###5.1.1需求分析流程

1）熟悉需求；

2）需求项整理；

3）提取测试点；

4）测试点细化；

5）测试子项分析；

6）测试设计。

###5.1.2需求分析方法

1）界面要素分析

 界面元素显示、页面布局等

2）功能点分析

单个功能点的处理：正常、异常操作

关联功能处理

3）功能交互分析

入口鲜明、 步骤简洁、交互结果正确

4）流程分析

流程是否走的通

其他不能使用的业务流程

5）用户场景分析

事件触发的场景

6）非功能性特征分析

兼容性、系统响应、性能特性

##5.2需求评审

需求是否合理

参加人员：产品需求人员、开发人员、测试人员

##5.3编写测试计划

包含内容：

1）标题、版本信息、测试计划各模块目录、文档目的和阅读人群。

2）测试时间安排、测试人员的分工

3）测试过程的准入准出标准

4）测试中需要用到的测试工具和版本号及运行平台，兼容哪些方面

5）测试环境的说明、风险评估。

严重程度：致命、严重、一般、轻微、建议

优先级：1234

包含：产品简介、测试目的、测试范围、测试工具、人员安排、时间安排、参考文档、测试提交文档、缺陷的严重程度和优先级的描述，测试风险，测试策略选择。

##5.4测试用例

指导测试工程师开展测试工作的文档 

包含内容：

用例编号、用例标题、预置条件、测试步骤和数据、预期结果、实际结果、优先级、设计者、备注、缺陷编号等

内容二：

项目名称、程序版本、测试目的/目标、预置条件（开展测试工作的前提条件）、参考信息、特殊规格说明、用例编号、测试模块、用例目的、标题、前置条件、测试/操作步骤、预期结果、优先级、实际结果、缺陷编号。

说明：评判用例的好坏：1、通俗易懂，容易操作；2、覆盖面全

##5.5测试用例评审

评审时间节点：

1）在初步完成测试用例以后（15%-20%）

2）全部完成以后

评审内容：

![1647166306028](C:\Users\asus\AppData\Local\Temp\1647166306028.png)

![1647166420043](C:\Users\asus\AppData\Local\Temp\1647166420043.png)

![1647166429811](C:\Users\asus\AppData\Local\Temp\1647166429811.png)

##5.6执行测试

###5.6.1测试策略

1、按照评审后的测试用例进行执行测试

先冒烟测试

再全面测试

然后根据需要回归测试

优先测试新功能

###5.6.2执行测试的时候需要注意的事项

![1647246327871](C:\Users\asus\AppData\Local\Temp\1647246327871.png)

![1647246367200](C:\Users\asus\AppData\Local\Temp\1647246367200.png)

#6.常见的dos命令

打开画板：mspaint

打开记事本： notepad

打开计算器：calc

打开注册表：regedit 

打开本地服务配置：services.msc

打开任务管理器：ctrl+Alt_del

打开资源管理器：win+E

关闭所有窗口：win+D

dir：表示显示当前目录下的所有文件和文件夹

cd+路径：切换当前路径到对应路径（如果切换到别的盘符的路径，需要先进入其他盘符）

cd.显示当前的目录

cd..显示上级目录

cd \回到到根目录

md 创建一个目录（创建文件夹）

cls 清空命令行窗口

ping ip:查看两台电脑是否通信

start:新建一个窗口

exit:关闭当前窗口

##6.1网络测试

查看网络通信：ipconfig /all

DNS协议：域名解析协议  把ip地址解析为域名

测试DNS解析：nslookup+网址

![1647499898841](C:\Users\asus\AppData\Local\Temp\1647499898841.png)

#7.批处理

![1647500546331](C:\Users\asus\AppData\Local\Temp\1647500546331.png)

http是不加密的  https是加密的协议

端口：80             端口：443

（想使用某种功能，必须经过这个端口）

批处理是对象进行批量的处理，通常被认为是一种简化的脚本语言

文件的后缀名.bat

-----批量处理事务（让所有的dos命令一起执行），批处理文件可以重复使用

dir:查看文件列表

md:创建文件夹

rd:删除目录

del:删除文件

**屏幕打印：**

echo：打开回显或关闭请求回显功能，或显示消息

echo off：从下一行开始关闭回显

@echo off:从本行开始关闭回显（不显示本身命令）

pause:暂停，等待按键继续

**注释：**

rem:注释命令，不执行操作

：：两个冒号也可以进行注释，如果遇到乱码的问题，在最前面加一个chcp 65501

 **系统类**：

shutdown：用于控制关机，包括定时  -s表示关机   -t后面是时间单位是秒

shutdown -s -t  600

shutdown -a 终止关机，关机之前执行

call:调用其他程序

call ahui.bat

重定向：将屏幕上的指定内容输入到文件中

echo hello world   >liwen.txt

#8.oracle常见的面试题

**1、 SQL语句分类： **

DQL(数据库查询语言)：select 

DML（数据库操作语言）：insert 、delete、update

DCL(数据库控制语言)：grant:把权限赋予用户、revoke：把权限收回

DDL（数据库定义语言）：create、drop、alter、truncate

TPL（TCL,事务控制语言）：commit、rollback

**2、oracle是怎么样分页的：**

Oracle用rownum进行分页

分页语句的步骤：

a.最内层sql，查询要分页的所有数据

b.第二层sql，通过rownum伪列确定显示数据的上限，并且给查询的数据添加rownum伪列的值

c.最外层sql，设置显示数据的下限

select * from

(select a.*,rownum r from

(select*from表名 where条件 orderby列) a

whererownum<=页数*条数) b where r>（页数-1）*条数

**3、 truncate和delete区别： **

1）Truncate和delete都可以将数据实体删掉，truncate操作不记录到rollback日志，同时数据不能恢复

2）Truncate是数据定义语言（DDL），delete是数据操作语言（DML）

3）Truncate不能对视图进行操作，delete操作不会腾出表空间的内存

**4、说说Oracle中经常使用到的函数**

length长度

lower小写

upper大写

to_date转化日期

to_char转化字符

to_number转化数字

Ltrim去左边空格

rtrim去右边空格

substr截取字符串

add_month增加或减掉月份

**5、主键有几种？**

复合型、整数型、字符型

**6、怎样创建一个索引，索引使用的原则，有什么优缺点？ **

create index 索引名 on 表名（列名）

原则：

建议索引列建立not null约束

经常与其他表进行连接的表，在连接列上建立索引

优缺点：

创建索引能大大加快检索速度，加强表与表的连接，但是创建索引很占用空间

**7、使用oracle伪列删除表中的重复数据中的一条？**

delete from table t wheret.rowid!=(select max(t1.rowid) from table t1 wheret.name=t1.name) 

**8、如何只显示重复数据？**

select * from table groupby id having count(*)>1 

**9、什么是数据库的映射？**

就是将数据库中表与字段对应到模型层类名与属性的过程 

**10、如何设计数据库？**

 首先分析项目，看看项目中有多少实体（矩形），为每个实体添加属性（椭圆），明确实体之间的关系（菱形），绘制E-R图，将E-R图转换成表格 

**11、如何实现数据库的优化 ？**

1）调整数据库结构的设计：需要考虑是否使用分区功能、是否建立索引等

2）调整数据库的SQL语句

3）调整服务器的内存分配

4）调整硬盘I/O

5）调整操作系统参数

**12、关系型数据库的关系操作有哪些？ **

选择（查询某些行）、投影（查询某些列）、链接（把多张表连接获取数据）、增加、删除、修改 

**13、SQL语句与SQL*PLUS命令的区别 ？**

1）SQL是关系型数据库的标准操作语言，而SQL*PLUS是一个客户端工具，除了执行标准的SQL外，还可以执行工具本身的一些命令。

2）SQL语句不可以缩写，而SQL*PLUS命令可以缩写

#9.SQL语法

SQL 是用于访问和处理数据库的标准的计算机语言。

**SQL能做什么？**

- SQL 面向数据库执行查询
- SQL 可从数据库取回数据
- SQL 可在数据库中插入新的记录
- SQL 可更新数据库中的数据
- SQL 可从数据库删除记录
- SQL 可创建新数据库
- SQL 可在数据库中创建新表
- SQL 可在数据库中创建存储过程
- SQL 可在数据库中创建视图
- SQL 可以设置表、存储过程和视图的权限

可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。 

DML:select、update、delete、insert into

DDL:create database、alter database、create table、alter table、drop table、create index、drop index

##9.1 select distinct语句

关键词 DISTINCT 用于返回唯一不同的值。 

```
SELECT DISTINCT 列名称 FROM 表名称
```

select distinct name from sm_user

##9.2 WHERE字句

如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。 

```
SELECT 列名称 FROM 表名称 WHERE 列 运算符 值
```

| 操作符  | 描述         |
| ------- | ------------ |
| =       | 等于         |
| <>      | 不等于       |
| >       | 大于         |
| <       | 小于         |
| >=      | 大于等于     |
| <=      | 小于等于     |
| BETWEEN | 在某个范围内 |
| LIKE    | 搜索某种模式 |

select * from sm_user where nick_name <> 'c0010'

##9.3 AND&OR 运算符

AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。 

```
SELECT * FROM Persons WHERE FirstName='Thomas' AND LastName='Carter'
```

##9.4  ORDER BY 语句

ORDER BY 语句用于根据指定的列对结果集进行排序。

ORDER BY 语句默认按照升序对记录进行排序。

如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。

select * from sm_user order by nick_name desc

##9.5 INSERT  INTO 语句

INSERT INTO 语句用于向表格中插入新的行。 

```
INSERT INTO 表名称 VALUES (值1, 值2,....)
```

我们也可以指定所要插入数据的列： 

```
INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)
```

insert into AA values（'h1111','测试','重症医学一科(31)','10','310c63f07b3448379f7d95049997a17a','71b7453f4fa04b2e9e50f14c803a64b1'）

insert into AA(staffnumber,name) values ('h1211','测试1')

##9.6 UPDATE 语句

Update 语句用于修改表中的数据。 

```
UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值
```

update AA SET NAME='测试2' where name='测试'

update AA SET NAME='测试1'，staffnumber='h1311' where name='测试3'

##9.7 DELETE 语句

```
DELETE FROM 表名称 WHERE 列名称 = 值
```

delete from AA WHERE NAME='测试1'

**删除所有行**

可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的： 

```
DELETE FROM table_name
```

或者：

```
DELETE * FROM table_name
```

##9.8 TOP语句

TOP 子句用于规定要返回的记录的数目。

对于拥有数千条记录的大型表来说，TOP 子句是非常有用的。

###9.8.1 SQL Server 的语法

```
SELECT TOP number|percent column_name(s)
FROM table_name
```

###9.8.2MYSQL和ORACLE的语法

MYSQL的语法

```
SELECT column_name(s)
FROM table_name
LIMIT number
```

select * from et_addonarticle limit 50

oracle语法

```
SELECT column_name(s)
FROM table_name
WHERE ROWNUM <= number
```

select name  from AA WHERE  ROWNUM <= 500

### 9.8.3 TOP实例

```
SELECT TOP 2 * FROM Persons
```

select top 2 * from AA

###9.8.4 TOP PERCENT实例

```
SELECT TOP 50 PERCENT * FROM Persons
```

## 9.9 LIKE操作符

LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。 

```
SELECT column_name(s)
FROM table_name
WHERE column_name LIKE pattern
```

select * from AA WHERE name like '%测%'

select * from AA WHERE name not like '%测%'

## 9.10通配符

在搜索数据库中的数据时，SQL 通配符可以替代一个或多个字符。

SQL 通配符必须与 LIKE 运算符一起使用。

在 SQL 中，可使用以下通配符：

| 通配符                     | 描述                       |
| -------------------------- | -------------------------- |
| %                          | 代表零个或多个字符         |
| _                          | 仅替代一个字符             |
| [charlist]                 | 字符列中的任何单一字符     |
| [^charlist]或者[!charlist] | 不在字符列中的任何单一字符 |

### 9.10.1使用 % 通配符

```
SELECT * FROM Persons
WHERE City LIKE 'Ne%'
```

### 9.10.2使用 _ 通配符

```
SELECT * FROM Persons
WHERE FirstName LIKE '_eorge'
```

### 9.10.3使用 [charlist] 通配符

```
SELECT * FROM Persons
WHERE City LIKE '[ALN]%'
```

select * from AA where staffnumber like '[ta]%'

##9.11 IN操作符

IN 操作符允许我们在 WHERE 子句中规定多个值。 

```
SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1,value2,...)
```

##9.12 BETWEEN 操作符

BETWEEN 操作符在 WHERE 子句中使用，作用是选取介于两个值之间的数据范围。

```
SELECT column_name(s)
FROM table_name
WHERE column_name
BETWEEN value1 AND value2
```

##9.13Alias别名

通过使用 SQL，可以为列名称和表名称指定别名（Alias）

1、表的语法

```
SELECT column_name(s)
FROM table_name
AS alias_name
```

2、列的语法

```
SELECT column_name AS alias_name
FROM table_name
```

select name as b from AA

## 9.14 JOIN语法

SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据

- iINNER JOIN (内连接)

- JOIN: 如果表中有至少一个匹配，则返回行

- LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行

- RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行

- FULL JOIN: 只要其中一个表中存在匹配，就返回行

  ```
  SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo
  FROM Persons
  INNER JOIN Orders
  ON Persons.Id_P = Orders.Id_P
  ORDER BY Persons.LastName
  ```

![1647759901722](C:\Users\asus\AppData\Local\Temp\1647759901722.png)

## 9.15 UNION和UNION ALL操作符

###9.15.1 UNION 操作符

UNION 操作符用于合并两个或多个 SELECT 语句的结果集。

请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。

```
SELECT column_name(s) FROM table_name1
UNION
SELECT column_name(s) FROM table_name2
```

select  E_ID,E_Name from Employees_China union select  E_ID,E_Name from Employees_USA

### 9.15.2 UNION ALL 语法

```
SELECT column_name(s) FROM table_name1
UNION ALL
SELECT column_name(s) FROM table_name2
```

select  E_ID,E_Name from Employees_China union all  select  E_ID,E_Name from Employees_USA

## 9.16 select into

**可用于创建表的备份复件** 。

SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。

SELECT INTO 语句常用于创建表的备份复件或者用于对记录进行存档。

您可以把所有的列插入新表：

```
SELECT *
INTO new_table_name [IN externaldatabase] 
FROM old_tablename
```

或者只把希望的列插入新表：

```
SELECT column_name(s)
INTO new_table_name [IN externaldatabase] 
FROM old_tablename
```

## 9.17 CREATE DATABASE语句

```
CREATE DATABASE database_name
```

## 9.18 CREATE TABLE语句

CREATE TABLE 语句用于创建数据库中的表。 

```
CREATE TABLE 表名称
(
列名称1 数据类型,
列名称2 数据类型,
列名称3 数据类型,
....
)
```

数据类型（data_type）规定了列可容纳何种数据类型。下面的表格包含了SQL中最常用的数据类型：

CREATE TABLE Person

(ID_P int,

LastName VARCHAR(255),

FirstName  VARCHAR(255),

Address VARCHAR(255),

City  VARCHAR(255)

 )

| 数据类型                                          | 描述                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ |
| integer(size)int(size)smallint(size)tinyint(size) | 仅容纳整数。在括号内规定数字的最大位数。                     |
| decimal(size,d)numeric(size,d)                    | 容纳带有小数的数字。"size" 规定数字的最大位数。"d" 规定小数点右侧的最大位数。 |
| char(size)                                        | 容纳固定长度的字符串（可容纳字母、数字以及特殊字符）。在括号中规定字符串的长度。 |
| varchar(size)                                     | 容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。在括号中规定字符串的最大长度。 |
| date(yyyymmdd)                                    | 容纳日期。                                                   |

## 9.19 SQL 约束

约束用于限制加入表的数据的类型。

可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后也可以（通过 ALTER TABLE 语句）。

我们将主要探讨以下几种约束：

- NOT NULL
- UNIQUE
- PRIMARY KEY
- FOREIGN KEY
- CHECK
- DEFAULT

###9.19.1 NOT NULL

NOT NULL 约束强制列不接受 NULL 值。

NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。

```
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
```

###9.19.2 UNIQUE约束

UNIQUE 约束唯一标识数据库表中的每条记录。

UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。

PRIMARY KEY 拥有自动定义的 UNIQUE 约束。

请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。

**MySQL:**

```
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
UNIQUE (Id_P)
)
```

**SQL Server / Oracle / MS Access:**

```
CREATE TABLE Persons
(
Id_P int NOT NULL UNIQUE,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
```

如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束，请使用下面的 SQL 语法：

**MySQL / SQL Server / Oracle / MS Access:**

```
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)
```

当表已被创建时，如需在 "Id_P" 列创建 UNIQUE 约束，请使用下列 SQL： 

```
ALTER TABLE Persons
ADD UNIQUE (Id_P)
```

**撤销 UNIQUE 约束**

如需撤销 UNIQUE 约束，请使用下面的 SQL：

**MySQL:**

```
ALTER TABLE Persons
DROP INDEX uc_PersonID
```

**SQL Server / Oracle / MS Access:**

```
ALTER TABLE Persons
DROP CONSTRAINT uc_PersonID
```

### 9.19.3 PRIMARY KEY 约束

PRIMARY KEY 约束唯一标识数据库表中的每条记录。

主键必须包含唯一的值。

主键列不能包含 NULL 值。

每个表都应该有一个主键，并且每个表只能有一个主键。

下面的 SQL 在 "Persons" 表创建时在 "Id_P" 列创建 PRIMARY KEY 约束：

**MySQL:**

```
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (Id_P)
)
```

**SQL Server / Oracle / MS Access:**

```
CREATE TABLE Persons
(
Id_P int NOT NULL PRIMARY KEY,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
```

### 9.19.4 FOREIGN KEY 约束

一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。 

**MYSQL:**

```
CREATE TABLE Orders
(
Id_O int NOT NULL,
OrderNo int NOT NULL,
Id_P int,
PRIMARY KEY (Id_O),
FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)
)
```

**SQL Server / Oracle / MS Access:**

```
CREATE TABLE Orders
(
Id_O int NOT NULL PRIMARY KEY,
OrderNo int NOT NULL,
Id_P int FOREIGN KEY REFERENCES Persons(Id_P)
)
```

### 9.19.5 CHECK 约束

CHECK 约束用于限制列中的值的范围。

如果对单个列定义 CHECK 约束，那么该列只允许特定的值。

如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。

**My SQL:**

```
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CHECK (Id_P>0)
)
```

**SQL Server / Oracle / MS Access:**

```
CREATE TABLE Persons
(
Id_P int NOT NULL CHECK (Id_P>0),
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
```

如果需要命名 CHECK 约束，以及为多个列定义 CHECK 约束，请使用下面的 SQL 语法： 

**MySQL / SQL Server / Oracle / MS Access:**

```
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT chk_Person CHECK (Id_P>0 AND City='Sandnes')
)
```

SQL CHECK Constraint on ALTER TABLE

如果在表已存在的情况下为 "Id_P" 列创建 CHECK 约束，请使用下面的 SQL：

**MySQL / SQL Server / Oracle / MS Access:**

```
ALTER TABLE Persons
ADD CHECK (Id_P>0)
```

如果需要命名 CHECK 约束，以及为多个列定义 CHECK 约束，请使用下面的 SQL 语法：

**MySQL / SQL Server / Oracle / MS Access:**

```
ALTER TABLE Persons
ADD CONSTRAINT chk_Person CHECK (Id_P>0 AND City='Sandnes')
```

**撤销 CHECK 约束**

如需撤销 CHECK 约束，请使用下面的 SQL：

**SQL Server / Oracle / MS Access:**

```
ALTER TABLE Persons
DROP CONSTRAINT chk_Person
```

**MySQL:**

```
ALTER TABLE Persons
DROP CHECK chk_Person
```

### 9.19.6 DEFULT 约束

DEFAULT 约束用于向列中插入默认值。

如果没有规定其他的值，那么会将默认值添加到所有的新记录。

下面的 SQL 在 "Persons" 表创建时为 "City" 列创建 DEFAULT 约束：

**My SQL / SQL Server / Oracle / MS Access:**

```
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255) DEFAULT 'Sandnes'
)
```

通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值：

```
CREATE TABLE Orders
(
Id_O int NOT NULL,
OrderNo int NOT NULL,
Id_P int,
OrderDate date DEFAULT GETDATE()
)
```

如果在表已存在的情况下为 "City" 列创建 DEFAULT 约束，请使用下面的 SQL：

**MySQL:**

```
ALTER TABLE Persons
ALTER City SET DEFAULT 'SANDNES'
```

**SQL Server / Oracle / MS Access:**

```
ALTER TABLE Persons
ALTER COLUMN City SET DEFAULT 'SANDNES'
```

**撤销 DEFAULT 约束**

如需撤销 DEFAULT 约束，请使用下面的 SQL：

**MySQL:**

```
ALTER TABLE Persons
ALTER City DROP DEFAULT
```

**SQL Server / Oracle / MS Access:**

```
ALTER TABLE Persons
ALTER COLUMN City DROP DEFAULT
```

##9.20 CREATE INDEX语句

您可以在表中创建索引，以便更加快速高效地查询数据。

用户无法看到索引，它们只能被用来加速搜索/查询。

注释：更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。

**SQL CREATE INDEX 语法**

在表上创建一个简单的索引。允许使用重复的值：

```
CREATE INDEX index_name
ON table_name (column_name)
```

**SQL CREATE UNIQUE INDEX 语法**

在表上创建一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。

```
CREATE UNIQUE INDEX index_name
ON table_name (column_name)
```

## 9.21 撤销索引、表以及数据库

**通过使用 DROP 语句，可以轻松地删除索引、表和数据库。** 

我们可以使用 DROP INDEX 命令删除表格中的索引。 

**用于 IBM DB2 和 Oracle 语法:**

```
DROP INDEX index_name
```

**用于 MySQL 的语法:**

```
ALTER TABLE table_name DROP INDEX index_name
```

DROP TABLE 语句用于删除表（表的结构、属性以及索引也会被删除）：

```
DROP TABLE 表名称
```

DROP DATABASE 语句用于删除数据库：

```
DROP DATABASE 数据库名称
```

**SQL TRUNCATE TABLE 语句**

如果我们仅仅需要除去表内的数据，但并不删除表本身，那么我们该如何做呢？

请使用 TRUNCATE TABLE 命令（仅仅删除表格中的数据）：

```
TRUNCATE TABLE 表名称
```

##9.22 ALTER TABLE 语句

ALTER TABLE 语句用于在已有的表中添加、修改或删除列。 

如需在表中添加列，请使用下列语法:

```
ALTER TABLE table_name
ADD column_name datatype
```

要删除表中的列，请使用下列语法：

```
ALTER TABLE table_name 
DROP COLUMN column_name
```

alter table persons add birthday date

alter table persons add birthday year

## 9.23 create view 

在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。

视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。

注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。

可以从某个查询内部、某个存储过程内部，或者从另一个视图内部来使用视图。通过向视图添加函数、join 等等，我们可以向用户精确地提交我们希望提交的数据。

样本数据库 Northwind 拥有一些被默认安装的视图。视图 "Current Product List" 会从 Products 表列出所有正在使用的产品。这个视图使用下列 SQL 创建：

```
CREATE VIEW [Current Product List] AS
SELECT ProductID,ProductName
FROM Products
WHERE Discontinued=No
```

我们可以查询上面这个视图：

```
SELECT * FROM [Current Product List]
```

您可以使用下面的语法来更新视图：

```
SQL CREATE OR REPLACE VIEW Syntax
CREATE OR REPLACE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
```

现在，我们希望向 "Current Product List" 视图添加 "Category" 列。我们将通过下列 SQL 更新视图：

```
CREATE VIEW [Current Product List] AS
SELECT ProductID,ProductName,Category
FROM Products
WHERE Discontinued=No
```

##9.24 Date 函数

当我们处理日期时，最难的任务恐怕是确保所插入的日期的格式，与数据库中日期列的格式相匹配。

只要数据包含的只是日期部分，运行查询就不会出问题。但是，如果涉及时间，情况就有点复杂了。

在讨论日期查询的复杂性之前，我们先来看看最重要的内建日期处理函数。

**MySQL Date 函数**

下面的表格列出了 MySQL 中最重要的内建日期函数：

| 函数                                                         | 描述                                |
| ------------------------------------------------------------ | ----------------------------------- |
| [NOW()](https://www.w3school.com.cn/sql/func_now.asp)        | 返回当前的日期和时间                |
| [CURDATE()](https://www.w3school.com.cn/sql/func_curdate.asp) | 返回当前的日期                      |
| [CURTIME()](https://www.w3school.com.cn/sql/func_curtime.asp) | 返回当前的时间                      |
| [DATE()](https://www.w3school.com.cn/sql/func_date.asp)      | 提取日期或日期/时间表达式的日期部分 |
| [EXTRACT()](https://www.w3school.com.cn/sql/func_extract.asp) | 返回日期/时间按的单独部分           |
| [DATE_ADD()](https://www.w3school.com.cn/sql/func_date_add.asp) | 给日期添加指定的时间间隔            |
| [DATE_SUB()](https://www.w3school.com.cn/sql/func_date_sub.asp) | 从日期减去指定的时间间隔            |
| [DATEDIFF()](https://www.w3school.com.cn/sql/func_datediff_mysql.asp) | 返回两个日期之间的天数              |
| [DATE_FORMAT()](https://www.w3school.com.cn/sql/func_date_format.asp) | 用不同的格式显示日期/时间           |

**SQL Server Date 函数**

下面的表格列出了 SQL Server 中最重要的内建日期函数：

| 函数                                                         | 描述                             |
| ------------------------------------------------------------ | -------------------------------- |
| [GETDATE()](https://www.w3school.com.cn/sql/func_getdate.asp) | 返回当前日期和时间               |
| [DATEPART()](https://www.w3school.com.cn/sql/func_datepart.asp) | 返回日期/时间的单独部分          |
| [DATEADD()](https://www.w3school.com.cn/sql/func_dateadd.asp) | 在日期中添加或减去指定的时间间隔 |
| [DATEDIFF()](https://www.w3school.com.cn/sql/func_datediff.asp) | 返回两个日期之间的时间           |
| [CONVERT()](https://www.w3school.com.cn/sql/func_convert.asp) | 用不同的格式显示日期/时间        |

**SQL Date 数据类型**

MySQL 使用下列数据类型在数据库中存储日期或日期/时间值：

- DATE - 格式 YYYY-MM-DD
- DATETIME - 格式: YYYY-MM-DD HH:MM:SS
- TIMESTAMP - 格式: YYYY-MM-DD HH:MM:SS
- YEAR - 格式 YYYY 或 YY

SQL Server 使用下列数据类型在数据库中存储日期或日期/时间值：

- DATE - 格式 YYYY-MM-DD
- DATETIME - 格式: YYYY-MM-DD HH:MM:SS
- SMALLDATETIME - 格式: YYYY-MM-DD HH:MM:SS
- TIMESTAMP - 格式: 唯一的数字

##9.25NULL值

null和is null

使用 IS NULL 操作符：

```
SELECT LastName,FirstName,Address FROM Persons
WHERE Address IS NULL
```

使用 IS NOT NULL 操作符：

```
SELECT LastName,FirstName,Address FROM Persons
WHERE Address IS NOT NULL
```

## 9.26 SQL函数

SQL 拥有很多可用于计数和计算的内建函数。

内建SQL函数的语法是select  function(列)  from 表

基本的函数类型有很多种，函数的基本类型是：

Aggregate 函数

Scalar 函数

合计函数（Aggregate functions）

### 在 SQL Server 中的合计函数

| 函数                                                         | 描述                                                     |
| ------------------------------------------------------------ | -------------------------------------------------------- |
| [AVG(column)](https://www.w3school.com.cn/sql/sql_func_avg.asp) | 返回某列的平均值                                         |
| BINARY_CHECKSUM                                              |                                                          |
| CHECKSUM                                                     |                                                          |
| CHECKSUM_AGG                                                 |                                                          |
| [COUNT(column)](https://www.w3school.com.cn/sql/sql_func_count.asp) | 返回某列的行数（不包括NULL值）                           |
| [COUNT(*)](https://www.w3school.com.cn/sql/sql_func_count_ast.asp) | 返回被选行数                                             |
| [COUNT(DISTINCT column)](https://www.w3school.com.cn/sql/sql_func_count_distinct.asp) | 返回相异结果的数目                                       |
| [FIRST(column)](https://www.w3school.com.cn/sql/sql_func_first.asp) | 返回在指定的域中第一个记录的值（SQLServer2000 不支持）   |
| [LAST(column)](https://www.w3school.com.cn/sql/sql_func_last.asp) | 返回在指定的域中最后一个记录的值（SQLServer2000 不支持） |
| [MAX(column)](https://www.w3school.com.cn/sql/sql_func_max.asp) | 返回某列的最高值                                         |
| [MIN(column)](https://www.w3school.com.cn/sql/sql_func_min.asp) | 返回某列的最低值                                         |
| STDEV(column)                                                |                                                          |
| STDEVP(column)                                               |                                                          |
| [SUM(column)](https://www.w3school.com.cn/sql/sql_func_sum.asp) | 返回某列的总和                                           |
| VAR(column)                                                  |                                                          |
| VARP(column)                                                 |                                                          |

### 9.26.1 AVG函数

AVG函数返回数值列的平均值，其中NULL值不包含在计算中。

select  avg(column_name) from table_name

![1647846178416](C:\Users\asus\AppData\Local\Temp\1647846178416.png)

计算 "OrderPrice" 字段的平均值。 

select avg(OrderPrice) as OrderaAverage  from orders

找到 OrderPrice 值高于 OrderPrice 平均值的客户 。

select customer from orders where OrderPrice >(select avg(OrderPrice)  from Orders) 

###9.26.2 COUNT()函数

count()函数返回匹配指定条件的行数

**count(column_name)语法**

select COUNT(column_name) from table_name

**count(*)语法**

select count(*) from table_name

**SQL COUNT(DISTINCT column_name) 语法**

select count(distinct column_name) from table_name

![1647847096339](C:\Users\asus\AppData\Local\Temp\1647847096339.png)

计算客户 "Carter" 的订单数。 

select count(customer)  as CustomerCount from Orders where customer='Carter'.

计算 "Orders" 表中不同客户的数目。 

select count(distinct customer)  CustomerCount from Orders.

### 9.26.3 FIRST()函数

FIRST() 函数返回指定的字段中第一个记录的值。 

select FIRST(column_name) from table_name

![1647847707303](C:\Users\asus\AppData\Local\Temp\1647847707303.png)

查找 "OrderPrice" 列的第一个值。 

select first(OrderPrice) as FirstOrderPrice from Orders

oracle:select* from sm_user where rownum=1

###9.26.4  LAST()函数

select LAST(column_name) from table_name

### 9.26.5 MAX()函数

MAX 函数返回一列中的最大值。NULL 值不包括在计算中。 

select max(column_name) from table_name

![1647848997302](C:\Users\asus\AppData\Local\Temp\1647848997302.png)

查找 "OrderPrice" 列的最大值。 

select max(OrderPrice) from Orders

###9.26.6 MIN()函数

MIN 函数返回一列中的最小值。NULL 值不包括在计算中。 

select min(column_name)  from Orders

###9.26.7 SUM()函数

SUM 函数返回数值列的总数（总额）。 

select sum(column_name) from table_name.

###9.26.8 GROUP BY 语句

GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。 

select column_name,aggregate_function(column_name) from table_name where table_name  operator value group by column_name.

### 9.26.9 HAVING 子句

在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。

```
SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name
HAVING aggregate_function(column_name) operator value
```

![1647849878526](C:\Users\asus\AppData\Local\Temp\1647849878526.png)

查找订单总金额少于 2000 的客户。 

select customer,sum(OrderPrice) from Orders  group by customer having sum(OrderPrice)<2000 

查找客户 "Bush" 或 "Adams" 拥有超过 1500 的订单总金额。 

select customer,sum(OrderPrice) from Orders  where customer='Bush' or 'Adams' group by customer  having sum(OrderPrice)>1500

### 9.26.7 UPPER函数

大写函数

select upper('Test') from AA

###9.26.8 LOWER函数

小写函数

select lower('Test') from AA

### 9.26.9 TO_CHAR函数

把日期和数字转换为制定格式的字符串。Fmt是格式化字符串 

SELECT TO_CHAR(SYSDATE,'YYYY"年"MM"月"DD"日" HH24:MI:SS')"date" FROM dual; 

![1647848696837](C:\Users\asus\AppData\Local\Temp\1647848696837.png)

###9.26.10 TO_DATE(X,[,fmt])

把一个字符串以fmt格式转换成一个日期类型

###9.26.11 TO_NUMBER(X,[,fmt])

把一个字符串以fmt格式转换为一个数字

代码演示：TO_NUM函数

SELECT TO_NUMBER('-$12,345.67','$99,999.99')"num" FROM dual;

###9.26.12 substr 函数

格式1： substr(string string, int a, int b);

格式2：substr(string string, int a) ;

**解释：**

​    格式1：
        1、string 需要截取的字符串 
        2、a 截取字符串的开始位置（注：当a等于0或1时，都是从第一位开始截取）
        3、b 要截取的字符串的长度
    格式2：
        1、string 需要截取的字符串
        2、a 可以理解为从第a个字符开始截取后面所有的字符串。

###9.26.13  length()函数

计算字符串的长度

select length('HelloWorld') from dual;

# 10.F12功能的简单介绍

  F12调试页面各个功能分别是什么？ 

##10.1Elements标签页

Elements标签页的左侧就是对页面HTML结构的查看与编辑，你可以直接在某个元素上双击修改元素的属性。

![img](https://img2018.cnblogs.com/blog/1017421/201810/1017421-20181009112204863-862968394.png) 

Elements标签页的右侧 

![img](https://img2018.cnblogs.com/blog/1017421/201810/1017421-20181009112215886-1353618376.png) 

##10.2Network标签页

Network标签页对于分析网站请求的网络情况、查看某一请求的请求头和响应头还有响应内容很有用。注意是在你打开Chrome开发者工具后发起的请求，才会在这里显示 

![img](https://img2018.cnblogs.com/blog/1017421/201810/1017421-20181009112227978-1348717541.png) 

## 10.3 sources标签页

Sources标签页可以查看到请求的资源情况，包括CSS、JS、图片等的内容。也可以设置各种断点。对存储的内容进行编辑然后保存也会实时的反应到页面上。 

![img](https://img2018.cnblogs.com/blog/1017421/201810/1017421-20181009112236552-1469961277.png) 

## 10.4Audits标签页 

这个对于优化前端页面、加速网页加载速度很有用;点击run按钮，就可以开始分析页面，分析完了就可以看到分析结果了 

![img](https://img2018.cnblogs.com/blog/1017421/201810/1017421-20181009112245949-1069130619.png) 

## 10.5Console标签页

就是Javascript控制台了 

![img](https://img2018.cnblogs.com/blog/1017421/201810/1017421-20181009112254204-1403249234.png) 

![img](https://img2018.cnblogs.com/blog/1017421/201810/1017421-20181009112303609-14395621.png) 

# 11.linux命令

##11.1 Linux管理文件和目录的命令

### 11.1.1 ls(list)

选项

含义

-a  列举目录中的全部文件，包括隐藏文件

-l  列举目录中的细节，包括权限、所有者、组群、大小、创建日期、文件是否是链接等

-f 列举的文件显示文件类型

-r 逆向，从后向前地列举目录中内容

-R 递归，该选项递归地列举当前目录下所有子目录内的内容

-s 大小，按文件大小排序

-h 以人类可读的方式显示文件的大小，如用K、M、G作单位

ls -l examples.doc

###11.1.2 pwd命令

print working directory(打印工作目录)。输入pwd命令，Linux会输出当前目录。 

###11.1.3 cd命令

cd命令用来改变所在目录。

cd /      转到根目录中 
cd ~     转到/home/user用户目录下 
cd /usr 转到根目录下的usr目录中-------------绝对路径 
cd test 转到当前目录下的test子目录中-------相对路径

###11.1.4cat命令

cat命令可以用来合并文件，也可以用来在屏幕上显示整个文件的内容。

cat snow.txt 该命令显示文件snow.txt的内容，ctrl+D退出cat。

###11.1.5 grep命令

grep命令的最大功能是在一堆文件中查找一个特定的字符串。

grep money test.txt

以上命令在test.txt中查找money这个字符串，grep查找是区分大小写的。

###11.1.6 touch命令

Access:最后访问时间，查看文件，这个时间会改变，使用cat命令查看文件时，可以看出Access时间改变了。

Modefy:最后修改时间，文件内容修改则Modefy便会改变。

Change:当文件的所有者或者权限等被修改时，Change时间就会改变。

touch -a file ：可以更改Access时间 

touch -m file : 可以更改Modify时间 

touch -c file :可以更改Change时间 

touch -d “指定日期” file ：将文件的日期修改为指定日期 

touch -r file1 file2 ：将file1的时间设置为file2的时间 

###11.1.7 cp命令

cp命令用来拷贝文件，要复制文件，输入命令：

cp <source filename> <targetfilename>

cp t.txt Document/t    该命令将把文件t.txt复制到Document目录下，并命名为t。

| -i   | 互动：如果文件将覆盖目标中的文件，他会提示确认 |
| ---- | ---------------------------------------------- |
| -r   | 递归：这个选项会复制整个目录树、子目录以及其他 |
| -v   | 详细：显示文件的复制进度                       |

###11.1.8 mv命令

| -i   | 互动：如果选择的文件会覆盖目标中的文件，他会提示确认       |
| ---- | ---------------------------------------------------------- |
| -f   | 强制：它会超越互动模式，不提示地移动文件，属于很危险的选项 |
| -v   | 详细：显示文件的移动进度                                   |

mv t.txt Document    把文件t.txt 移动到目录Document中。 

###11.1.9 rm 命令

rm命令用来删除文件。 

| 选项 | 说明                                           |
| ---- | ---------------------------------------------- |
| -i   | 互动：提示确认删除                             |
| -f   | 强制：代替互动模式，不提示确认删除             |
| -v   | 详细：显示文件的删除进度                       |
| -r   | 递归：将删除某个目录以及其中所有的文件和子目录 |

rm t.txt   该命令删除文件t.txt 

###11.1.10 rmdir 命令

rmdir命令用来删除目录。 

11.11 vi编辑文件

进入vi的命令

    vi filename :打开或新建文件,并将光标置于第一行首
    vi n filename ：打开文件,并将光标置于第n行首
    vi filename ：打开文件,并将光标置于一行首
    vi /pattern filename：打开文件,并将光标置于第一个与pattern匹配的串处
    vi -r filename ：在上次正用vi编辑时发生系统崩溃,恢复filename
    vi filename....filename ：打开多个文件,依次进行编辑
插入文本类命令

    i ：在光标前
    I ：在当前行首
    a：光标后
    A：在当前行尾
    o：在当前行之下新开一行
    O：在当前行之上新开一行
    r：替换当前字符
    R：替换当前字符及其后的字符,直至按ESC键
    s：从当前光标位置处开始,以输入的文本替代指定数目的字符

 保存命令
    按ESC键 跳到命令模式，然后：
     
    :w   保存文件但不退出vi
    :w file 将修改另外保存到file中，不退出vi
    :w!   强制保存，不推出vi
    :wq  保存文件并退出vi
    :wq! 强制保存文件，并退出vi
    :q  不保存文件，退出vi
    :q! 不保存文件，强制退出vi
    :e! 放弃所有修改，从上次保存文件开始再编辑
## 11.2 文件备份和压缩命令

| 命令          | 功能                         |
| ------------- | ---------------------------- |
| bzip2/bunzip2 | 扩展名为bz2的压缩/解压缩工具 |
| gzip/gunzip   | 扩展名为gz的压缩/解压缩工具  |
| zip/unzip     | 扩展名为zip的压缩/解压缩工具 |
| tar           | 创建备份和归档               |

###11.2.1 bzip2命令压缩文件

在shell提示下输入命令：

bzip2 filename

文件即会被压缩，并被保存为filename.bz2。

要解压缩文件，输入命令：

bunzip2 filename.bz2

filename.bz2会被删除，而以filename代替。

bzip2 filename.bz2 file1 file2 file3/usr/work/school

上面的命令把file1、file2、file3以及/usr/work/school目录中的内容压缩起来放入filename.bz2。
